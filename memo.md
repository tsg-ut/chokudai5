* 連結成分を一色に染める satos
* グラフにして，盤面全体を1色に染めるとよさそう
  * グラフは二部グラフとみなせそうです（使えなさそう）
    * くっつけていってもグラフの平面性は保たれそう
      * 保たれます。後述

* いちばん連結成分数が減る貪欲法とかもありそう
  * この貪欲が嘘になるテストケース思いついたりしますか？(僕は思いつけなんだ)
    * 同じ連結成分数の場合にどれを変更するかがむずそう(どれを変更しても最適だったりしますか？)
      * ABCAみたいなのがあると，B,Cを先に変更する必要がある
        * ので，減る連結成分数が同じ場合は次数の高い頂点を選ぶ，とかになる？？(ほんまか) -> ぐえ
          * ABCDBAみたいな場合，C,Dを先に選ばにゃいかんのだがこれどうするんだ
      * ランダムに変更する、を繰り返してスコアが最高になる手法を取ればよさそう
        * この方針なら、Queryの配列を与えられて得点を計算する関数が必要
        * 変更する箇所を変えるとそこから先の盤面の状態が変わるので、ランダムswapなどを使えない
        * 
  * メモ: 隣接するノードの数が最大なブロックの色を変更するというのとは違いそう？

* A  B
 AXABYB
  A  B
  みたいなのを考えると，XをAに，YをBにしたあとまとめると早いので，
  全てのタイルをある1色に変更するだけでよい，は偽そう

* グラフ理論的な解釈
 同色の塊をノードとし、塊同士の隣接性を変とするグラフを考える。（辺で結ばれたノード同士は色が異なると言える）
 操作の結果、同色ノードが隣接した（辺で結ばれた）状態になったら、それら（を結ぶ辺）を **縮約** する。
 これを繰り返し、ノード一個だけの寂しいグラフにすれば勝ち。（本当は最後に決まった色で塗らないといけないけど、1手だし無視無視）
 ノードが持つべき情報は色だけであり、ノードを構成するパネルの数（いわば面積）は無視してしまっていい。なぜならどうせ最後にはノード一個になるから。

* アルゴリズム1( ~~これ間に合わないんだって~~ なんか間に合った)
 各ノードnに対し、「nの隣接ノードたちのうち最も多い(i_n個)色はc_n色だ」として、i_nを最大にするnをn~として、n~をc_n~色にする。これを繰り返す。
 * グラフで起こること
  n~とそのc_n~色の隣接ノードとを結ぶ辺たちが縮約される。ノードがi_n~個減る。

* アルゴリズム1.1 中心プリファー
 同着のノードがあったら中心を優先
 * 中心を取って悪くなるなら端をとるようにして点数が上がったりしませんか（雑）
　
* アルゴリズム2(satos is genius)
 全ノードが隣接しているような頂点を1つ作ると残り9回になる
 * 一般に グラフの最小頂点被覆 * 9 回でできる

* アルゴリズム3(divide and conque)
 マップを10x10の小マップに分割し各小マップで塗りつぶす→全体マップで塗りつぶす
 * 10x10なら最適化できないか？

* グラフの縮約
 こことか見て（説明放棄）http://lealgorithm.blogspot.com/2017/03/blog-post_23.html
 グラフの平面性は縮約によって損なわれることがないので、盤面の状態を表すグラフはずっと平面グラフである。
 Gの縮約によって作れるグラフのことを「Gのグラフマイナー」という。
 グラフマイナー関係は束(lattice)をなすよ
 この問題で許された縮約だけに絞っても束になる

* ABCA問題
 縮約した後の嬉しさ(嬉しさとはi_n~)を、縮約前に予測できないか？（これが昆布の頭の最先端） ~~このアプローチで計算量も解決できちゃうといいね（本当に適当）~~

#### スコア計算
* 盤面のコピーは、スコア計算時に盤面を変更しながらやっているためです

#### つぶやき
* 勝手にマクロを変えちゃってくださいbow (sh-mug)
* あ！テストケースが与えられとるな (sh-mug)
* 発言はSlackにかきます (sh-mug)
* 古池や namespace MMNMM (kom-bu)
* 計算量やばくない？
>real    0m24.917s
>user    0m24.594s
>sys     0m0.047s